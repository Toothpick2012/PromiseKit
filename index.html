<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Promisekit by mxcl</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1>Promisekit</h1>
        <p>A delightful Promises implementation for iOS</p>
        <p class="view"><a href="https://github.com/mxcl/PromiseKit">View the Project on GitHub <small>mxcl/PromiseKit</small></a></p>
        <ul>
          <li><a href="https://github.com/mxcl/PromiseKit/zipball/master">Download <strong>ZIP File</strong></a></li>
          <li><a href="https://github.com/mxcl/PromiseKit/tarball/master">Download <strong>TAR Ball</strong></a></li>
          <li><a href="https://github.com/mxcl/PromiseKit">View On <strong>GitHub</strong></a></li>
        </ul>
      </header>
      <section>
        <p>Modern development is highly asynchronous: isn’t it about time iOS developers had tools that made programming asynchronously powerful, easy and delightful?</p>

<p>PromiseKit is not just a <a href="http://wikipedia.org/wiki/Promise_%28programming%29">Promises</a> implementation, it is also a collection of helper functions that make the typical asynchronous patterns we use in iOS development delightful <em>too</em>.</p>

<p>PromiseKit is also designed to be integrated into other CocoaPods. If your library has asynchronous operations and you like PromiseKit, then add an opt-in subspec that provides Promises for your users. Documentation to help you integrate PromiseKit into your own pods is provided later in this guide.</p>

<h1>
<a name="importing-promisekit" class="anchor" href="#importing-promisekit"><span class="octicon octicon-link"></span></a>Importing PromiseKit</h1>

<p>In your <a href="http://guides.cocoapods.org/using/the-podfile.html">Podfile</a>:</p>

<div class="highlight highlight-ruby"><pre><span class="n">pod</span> <span class="s1">'PromiseKit'</span>
</pre></div>

<p>PromiseKit is modulized; if you only want <code>Promise</code> and none of our category additions:</p>

<div class="highlight highlight-ruby"><pre><span class="n">pod</span> <span class="s1">'PromiseKit/base'</span>
</pre></div>

<p>Or if you only want some of our categories:</p>

<div class="highlight highlight-ruby"><pre><span class="n">pod</span> <span class="s1">'PromiseKit/Foundation'</span>
<span class="n">pod</span> <span class="s1">'PromiseKit/UIKit'</span>
<span class="n">pod</span> <span class="s1">'PromiseKit/CoreLocation'</span>
<span class="n">pod</span> <span class="s1">'PromiseKit/MapKit'</span>
</pre></div>

<h1>
<a name="why-promises" class="anchor" href="#why-promises"><span class="octicon octicon-link"></span></a>Why Promises?</h1>

<p>Synchronous code is clean code. For example, here's the synchronous code to show a gravatar image:</p>

<div class="highlight highlight-objc"><pre><span class="n">NSString</span> <span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
<span class="n">NSString</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="s">@"http://gravatar.com/avatar/"</span> <span class="n">stringByAppendingString</span><span class="o">:</span><span class="n">md5</span><span class="p">];</span>
<span class="n">NSData</span> <span class="o">*</span><span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="n">dataWithContentsOfURL</span><span class="o">:</span><span class="p">[</span><span class="n">NSURL</span> <span class="n">URLWithString</span><span class="o">:</span><span class="n">url</span><span class="p">]];</span>
<span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageWithData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
</pre></div>

<p>Clean but blocking: the UI lags: the user rates you one star.</p>

<p>The asynchronous analog suffers from <em>rightward-drift</em>:</p>

<div class="highlight highlight-objc"><pre><span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">md5</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
    <span class="n">NSString</span> <span class="o">*</span><span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="s">@"http://gravatar.com/avatar/"</span> <span class="n">stringByAppendingString</span><span class="o">:</span><span class="n">md5</span><span class="p">];</span>
    <span class="n">NSURLRequest</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLRequest</span> <span class="n">requestWithURL</span><span class="o">:</span><span class="p">[</span><span class="n">NSURL</span> <span class="n">URLWithString</span><span class="o">:</span><span class="n">url</span><span class="p">]];</span>
    <span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">sendAsynchronousRequest</span><span class="o">:</span><span class="n">rq</span> <span class="n">queue</span><span class="o">:</span><span class="p">[</span><span class="n">NSOperationQueue</span> <span class="n">currentQueue</span><span class="p">]</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">connectionError</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">UIImage</span> <span class="o">*</span><span class="n">gravatarImage</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageWithData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">gravatarImage</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}];</span>
<span class="p">});</span>
</pre></div>

<p>The code that does the actual work is now buried inside asynchronicity boilerplate. It is harder to read. The code is less clean.</p>

<p>Promises are chainable, standardized representations of asynchronous tasks. The equivalent code with PromiseKit looks like this:</p>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit.h"</span>

<span class="n">dispatch_promise</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">md5</span><span class="p">){</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://gravatar.com/avatar/%@"</span><span class="p">,</span> <span class="n">md5</span><span class="p">];</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="n">gravatarImage</span><span class="p">){</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">gravatarImage</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>Code with promises is about as close as we can get to the minimal cleanliness of synchronous code.</p>

<h2>
<a name="explaining-that-promise-code" class="anchor" href="#explaining-that-promise-code"><span class="octicon octicon-link"></span></a>Explaining That Promise Code</h2>

<p>A <code>Promise</code> represents the <em>future</em> value of an asynchronous task. To obtain the value of that future, we <code>then</code> off the Promise.</p>

<div class="highlight highlight-objc"><pre><span class="n">Promise</span> <span class="o">*</span><span class="n">promise</span> <span class="o">=</span> <span class="n">dispatch_promise</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">// we’re in a background thread</span>
    <span class="k">return</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
<span class="p">});</span>

<span class="c1">// `dispatch_promise` returns a promise representing the future</span>
<span class="c1">// value of the block it executes. You can `then` off any</span>
<span class="c1">// Promise object and it will receive the previous Promise’s</span>
<span class="c1">// value as its parameter.</span>

<span class="n">promise</span> <span class="o">=</span> <span class="n">promise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">md5</span><span class="p">){</span>
    <span class="c1">// we’re back in the main thread</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://gravatar.com/avatar/%@"</span><span class="p">,</span> <span class="n">md5</span><span class="p">];</span>
<span class="p">});</span>

<span class="c1">// The previous `then` returned a Promise. The next Promise</span>
<span class="c1">// will not execute any `then`s until that Promise is fulfilled.</span>

<span class="n">promise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="n">gravatarImage</span><span class="p">){</span>
    <span class="c1">// The previous promise has fulfilled and provided</span>
    <span class="c1">// a `UIImage`. So lets finish and set the Gravatar.</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">gravatarImage</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<h1>
<a name="error-handling" class="anchor" href="#error-handling"><span class="octicon octicon-link"></span></a>Error Handling</h1>

<p>Synchronous code has simple, clean error handling:</p>

<div class="highlight highlight-objc"><pre><span class="k">@try</span> <span class="p">{</span>
    <span class="kt">id</span> <span class="n">md5</span> <span class="o">=</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
    <span class="kt">id</span> <span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="s">@"http://gravatar.com/avatar/"</span> <span class="n">stringByAppendingString</span><span class="o">:</span><span class="n">md5</span><span class="p">];</span>
    <span class="n">url</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURL</span> <span class="n">URLWithString</span><span class="o">:</span><span class="n">url</span><span class="p">];</span>
    <span class="kt">id</span> <span class="n">error</span><span class="p">;</span>
    <span class="kt">id</span> <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSData</span> <span class="n">dataWithContentsOfURL</span><span class="o">:</span><span class="n">url</span> <span class="n">options</span><span class="o">:</span><span class="mi">0</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">error</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="k">@throw</span> <span class="n">error</span><span class="p">;</span>
    <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="p">[</span><span class="n">UIImage</span> <span class="n">imageWithData</span><span class="o">:</span><span class="n">data</span><span class="p">];</span>
<span class="p">}</span> <span class="k">@catch</span> <span class="p">(</span><span class="kt">id</span> <span class="n">thrownObject</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">}</span>
</pre></div>

<p>Error handling with asynchronous code is notoriously tricky. Here's an example using <code>NSURLConnection</code>, CoreLocation and MapKit:</p>

<div class="highlight highlight-objc"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">^</span><span class="n">errorHandler</span><span class="p">)(</span><span class="n">NSError</span> <span class="o">*</span><span class="p">)</span> <span class="o">=</span> <span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">};</span>

<span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">sendAsynchronousRequest</span><span class="o">:</span><span class="n">rq</span> <span class="n">queue</span><span class="o">:</span><span class="p">[</span><span class="n">NSOperationQueue</span> <span class="n">mainQueue</span><span class="p">]</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSURLResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">connectionError</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connectionError</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">errorHandler</span><span class="p">(</span><span class="n">connectionError</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="kt">id</span> <span class="n">jsonError</span><span class="p">;</span>
        <span class="kt">id</span> <span class="n">json</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSJSONSerialization</span> <span class="n">JSONObjectWithData</span><span class="o">:</span><span class="n">data</span> <span class="n">options</span><span class="o">:</span><span class="mi">0</span> <span class="n">error</span><span class="o">:&amp;</span><span class="n">jsonError</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">jsonError</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">errorHandler</span><span class="p">(</span><span class="n">jsonError</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="kt">id</span> <span class="n">home</span> <span class="o">=</span> <span class="p">[</span><span class="n">json</span> <span class="n">valueForKeyPath</span><span class="o">:</span><span class="s">@"user.home.address"</span><span class="p">];</span>
            <span class="p">[[</span><span class="n">CLGeocoder</span> <span class="n">new</span><span class="p">]</span> <span class="n">geocodeAddressString</span><span class="o">:</span><span class="n">home</span> <span class="n">completionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">placemarks</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                    <span class="n">errorHandler</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
                <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                    <span class="n">MKDirectionsRequest</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKDirectionsRequest</span> <span class="n">new</span><span class="p">];</span>
                    <span class="n">rq</span><span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKMapItem</span> <span class="n">mapItemForCurrentLocation</span><span class="p">];</span>
                    <span class="n">rq</span><span class="p">.</span><span class="n">destination</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MKMapItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithPlacemark</span><span class="o">:</span><span class="p">[[</span><span class="n">MKPlacemark</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithPlacemark</span><span class="o">:</span><span class="n">placemarks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]];</span>
                    <span class="n">MKDirections</span> <span class="o">*</span><span class="n">directions</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MKDirections</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithRequest</span><span class="o">:</span><span class="n">rq</span><span class="p">];</span>
                    <span class="p">[</span><span class="n">directions</span> <span class="n">calculateDirectionsWithCompletionHandler</span><span class="o">:^</span><span class="p">(</span><span class="n">MKDirectionsResponse</span> <span class="o">*</span><span class="n">response</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                            <span class="n">errorHandler</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
                        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                            <span class="c1">//…</span>
                        <span class="p">}</span>
                    <span class="p">}];</span>
                <span class="p">}</span>
            <span class="p">}];</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}];</span>
</pre></div>

<p>Not only does this code drift ever rightwards, reducing readability, but it doesn't even handle exceptions that might be thrown (like if there are zero placemarks in the <code>placemarks</code> array). The code doesn’t even decode the JSON in a background thread, which may introduce UI lag. But who would want to add <em>another</em> closure?</p>

<h2>
<a name="promises-have-elegant-error-handling" class="anchor" href="#promises-have-elegant-error-handling"><span class="octicon octicon-link"></span></a>Promises Have Elegant Error Handling</h2>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit.h"</span>

<span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">promise</span><span class="o">:</span><span class="n">rq</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">json</span><span class="p">){</span>
    <span class="kt">id</span> <span class="n">home</span> <span class="o">=</span> <span class="p">[</span><span class="n">json</span> <span class="n">valueForKeyPath</span><span class="o">:</span><span class="s">@"user.home.address"</span><span class="p">];</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">CLGeocoder</span> <span class="n">geocode</span><span class="o">:</span><span class="n">home</span><span class="p">];</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">placemarks</span><span class="p">){</span>
    <span class="n">MKDirectionsRequest</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKDirectionsRequest</span> <span class="n">new</span><span class="p">];</span>
    <span class="n">rq</span><span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKMapItem</span> <span class="n">mapItemForCurrentLocation</span><span class="p">];</span>
    <span class="n">rq</span><span class="p">.</span><span class="n">destination</span> <span class="o">=</span> <span class="p">[[</span><span class="n">MKMapItem</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithPlacemark</span><span class="o">:</span><span class="p">[[</span><span class="n">MKPlacemark</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithPlacemark</span><span class="o">:</span><span class="n">placemarks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]];</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">MKDirections</span> <span class="n">promise</span><span class="o">:</span><span class="n">rq</span><span class="p">];</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">MKDirectionsResponse</span> <span class="o">*</span><span class="n">directions</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<p>Raised exceptions or <code>NSError</code> objects returned from handlers bubble up to the first <code>catch</code> handler in the chain.</p>

<p>The above makes heavy use of PromiseKit’s category additions to the iOS SDK. Mostly PromiseKit’s categories are logical conversions of block-based or delegation-based patterns to Promises. The exception here is <code>NSURLConnection+PromiseKit</code> which detects that the response in JSON (from the HTTP headers) and deserializes the JSON for you in a background thread. All of PromiseKit’s categories are optional CocoaPods subspecs.</p>

<h1>
<a name="say-goodbye-to-asynchronous-state-machines" class="anchor" href="#say-goodbye-to-asynchronous-state-machines"><span class="octicon octicon-link"></span></a>Say Goodbye to Asynchronous State Machines</h1>

<p>Promises represent the future value of a task. You can add more than one <code>then</code> handler to a promise. Even after the promise has been fulfilled. If the promise already has a value, the then handler is called immediately:</p>

<div class="highlight highlight-objc"><pre><span class="k">@implementation</span> <span class="nc">MyViewController</span> <span class="p">{</span>
    <span class="n">Promise</span> <span class="o">*</span><span class="n">gravatar</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">viewDidLoad</span> <span class="p">{</span>
    <span class="n">gravatar</span> <span class="o">=</span> <span class="n">dispatch_promise</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
        <span class="k">return</span> <span class="n">md5</span><span class="p">(</span><span class="n">email</span><span class="p">);</span>
    <span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">md5</span><span class="p">){</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://gravatar.com/avatar/%@"</span><span class="p">,</span> <span class="n">md5</span><span class="p">];</span>
    <span class="p">});</span>

    <span class="n">gravatar</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">){</span>
        <span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="o">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">someTimeLater</span> <span class="p">{</span>
    <span class="n">gravatar</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">){</span>
        <span class="c1">// likely called immediately, but maybe not. We don’t have to worry!</span>
        <span class="n">self</span><span class="p">.</span><span class="n">otherImageView</span><span class="p">.</span><span class="n">image</span> <span class="o">=</span> <span class="n">image</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>

<p>A key understanding is that Promises can only exist in two states, <em>pending</em> or <em>fulfilled</em>. The fulfilled state is either a value or an <code>NSError</code> object. A Promise can move from pending to fulfilled <strong>exactly once</strong>. Whichever state the Promise is in, you can <code>then</code> off it.</p>

<h1>
<a name="waiting-on-multiple-asynchronous-operations" class="anchor" href="#waiting-on-multiple-asynchronous-operations"><span class="octicon octicon-link"></span></a>Waiting on Multiple Asynchronous Operations</h1>

<p>One common reason to use asynchronous variants is so we can do two or more asynchronous operations simultaneously. However writing code that acts when all the simultaneous operations have completed is tricky and bug-prone. Not so with PromiseKit:</p>

<div class="highlight highlight-objc"><pre><span class="n">Promise</span> <span class="o">*</span><span class="n">grabcat</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://placekitten.org/%d/%d"</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">h</span><span class="p">];</span>
<span class="n">Promise</span> <span class="o">*</span><span class="n">locater</span> <span class="o">=</span> <span class="p">[</span><span class="n">CLLocationManager</span> <span class="n">promise</span><span class="p">];</span>

<span class="p">[</span><span class="n">Promise</span> <span class="n">when</span><span class="o">:</span><span class="p">@[</span><span class="n">grabcat</span><span class="p">,</span> <span class="n">locater</span><span class="p">]].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">results</span><span class="p">){</span>
    <span class="c1">// results[0] is the `UIImage *` from grabcat</span>
    <span class="c1">// results[1] is the `CLLocation *` from locater</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">// with `when`, if any of the Promises fail, the `catch` handler is executed</span>
    <span class="n">NSArray</span> <span class="o">*</span><span class="n">suberrors</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">userInfo</span><span class="p">[</span><span class="n">PMKThrown</span><span class="p">];</span>

    <span class="c1">// `suberrors` may not just be `NSError` objects, any promises that succeeded</span>
    <span class="c1">// have their success values passed to this handler also. Thus you could</span>
    <span class="c1">// return a value from this `catch` and have the Promise chain continue, if</span>
    <span class="c1">// you don't care about certain errors or can recover.</span>
<span class="p">});</span>
</pre></div>

<h1>
<a name="tolerant-to-the-max" class="anchor" href="#tolerant-to-the-max"><span class="octicon octicon-link"></span></a>Tolerant to the Max</h1>

<p>The block you pass to <code>then</code> or <code>catch</code> can have return type of <code>Promise</code>, or any object, or nothing. And it can have a parameter of <code>id</code>, or a specific class type, or nothing.</p>

<p>So all of these are valid:</p>

<div class="highlight highlight-objc"><pre><span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>

<span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>

<span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">obj</span><span class="p">){</span>
    <span class="k">return</span> <span class="mi">@1</span><span class="p">;</span>
<span class="p">});</span>

<span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="mi">@2</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>Clang is smart so you don’t (usually) have to specify a return type for your block.</p>

<p>This is not usual to Objective-C or blocks. Usually everything is very explicit. We are using introspection to determine what arguments and return types you are working with. Thus, programming with PromiseKit has similarities to programming with (more) modern languages like Ruby or Javascript.</p>

<p>In fact these (and more) are also fine:</p>

<div class="highlight highlight-objc"><pre><span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">n</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">([</span><span class="n">n</span> <span class="n">isEqual</span><span class="o">:</span><span class="mi">@1</span><span class="p">]);</span>
<span class="p">});</span>

<span class="n">myPromise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}).</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">n</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">([</span><span class="n">n</span> <span class="n">isEqual</span><span class="o">:</span><span class="p">@</span><span class="nb">NO</span><span class="p">]);</span>
<span class="p">});</span>
</pre></div>

<h1>
<a name="the-category-additions" class="anchor" href="#the-category-additions"><span class="octicon octicon-link"></span></a>The Category Additions</h1>

<p>PromiseKit aims to provide a category analog for all one-time asynchronous operations in the iOS SDK.</p>

<p>Notably we don’t provide a Promise for eg. <code>UIButton</code> actions. Promises can only resolve once, and buttons can be pushed again and again.</p>

<h2>
<a name="nsurlconnectionpromisekit" class="anchor" href="#nsurlconnectionpromisekit"><span class="octicon octicon-link"></span></a>NSURLConnection+PromiseKit</h2>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+Foundation.h"</span>

<span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://promisekit.org"</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>

<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="n">NSHTTPURLResponse</span> <span class="o">*</span><span class="n">rsp</span> <span class="o">=</span> <span class="n">error</span><span class="p">.</span><span class="n">userInfo</span><span class="p">[</span><span class="n">PMKURLErrorFailingURLResponse</span><span class="p">];</span>
    <span class="kt">int</span> <span class="n">HTTPStatusCode</span> <span class="o">=</span> <span class="n">rsp</span><span class="p">.</span><span class="n">statusCode</span><span class="p">;</span>
<span class="p">});</span>
</pre></div>

<p>And a convenience string format variant:</p>

<div class="highlight highlight-objc"><pre><span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://example.com/%@"</span><span class="p">,</span> <span class="n">folder</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<p>And a variant that constructs a correctly URL encoded query string from a dictionary:</p>

<div class="highlight highlight-objc"><pre><span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://example.com"</span> <span class="n">query</span><span class="o">:</span><span class="p">@{</span><span class="s">@"foo"</span><span class="o">:</span> <span class="s">@"bar"</span><span class="p">}].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<p>And a POST variant:</p>

<div class="highlight highlight-objc"><pre><span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">POST</span><span class="o">:</span><span class="s">@"http://example.com"</span> <span class="n">formURLEncodedParameters</span><span class="o">:</span><span class="p">@{</span><span class="s">@"key"</span><span class="o">:</span> <span class="s">@"value"</span><span class="p">}].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<p>PromiseKit reads the response headers and decodes the result you actually wanted (in a background thread):</p>

<div class="highlight highlight-objc"><pre><span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://example.com/some.json"</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSDictionary</span> <span class="o">*</span><span class="n">json</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">([</span><span class="n">json</span> <span class="n">isKindOfClass</span><span class="o">:</span><span class="p">[</span><span class="n">NSDictionary</span> <span class="n">class</span><span class="p">]]);</span>
<span class="p">});</span>

<span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">GET</span><span class="o">:</span><span class="s">@"http://placekitten.org/100/100"</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="n">image</span><span class="p">){</span>
    <span class="n">assert</span><span class="p">([</span><span class="n">image</span> <span class="n">isKindOfClass</span><span class="o">:</span><span class="p">[</span><span class="n">UIImage</span> <span class="n">class</span><span class="p">]]);</span>
<span class="p">});</span>
</pre></div>

<p>Otherwise we return the raw <code>NSData</code>.</p>

<p>And of course a variant that just takes an <code>NSURLRequest *</code>:</p>

<div class="highlight highlight-objc"><pre><span class="n">NSMutableURLRequest</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableURLRequest</span> <span class="n">requestWithURL</span><span class="o">:</span><span class="n">url</span><span class="p">];</span>
<span class="p">[</span><span class="n">rq</span> <span class="n">addValue</span><span class="o">:</span><span class="s">@"PromiseKit"</span> <span class="n">forHTTPHeader</span><span class="o">:</span><span class="s">@"User-Agent"</span><span class="p">];</span> 
<span class="p">[</span><span class="n">NSURLConnection</span> <span class="n">promise</span><span class="o">:</span><span class="n">rq</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSData</span> <span class="o">*</span><span class="n">data</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">})</span>
</pre></div>

<h2>
<a name="cllocationmanagerpromisekit" class="anchor" href="#cllocationmanagerpromisekit"><span class="octicon octicon-link"></span></a>CLLocationManager+PromiseKit</h2>

<p>A Promise to get the user’s location:</p>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+CoreLocation.h"</span>

<span class="p">[</span><span class="n">CLLocationManager</span> <span class="n">promise</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">CLLocation</span> <span class="o">*</span><span class="n">currentUserLocation</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<h2>
<a name="clgeocoderpromisekit" class="anchor" href="#clgeocoderpromisekit"><span class="octicon octicon-link"></span></a>CLGeocoder+PromiseKit</h2>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+CoreLocation.h"</span>

<span class="p">[</span><span class="n">CLGeocoder</span> <span class="n">geocode</span><span class="o">:</span><span class="s">@"mount rushmore"</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">placemarks</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>

<span class="n">CLLocation</span> <span class="o">*</span><span class="n">someLocation</span> <span class="o">=</span> <span class="err">…</span><span class="p">;</span>
<span class="p">[</span><span class="n">CLGeocoder</span> <span class="n">reverseGeocode</span><span class="o">:</span><span class="n">someLocation</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">placemarks</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<h2>
<a name="uialertviewpromisekit" class="anchor" href="#uialertviewpromisekit"><span class="octicon octicon-link"></span></a>UIAlertView+PromiseKit</h2>

<p>A promise for showing a <code>UIAlertView</code>:</p>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+UIKit.h"</span>

<span class="n">UIAlertView</span> <span class="o">*</span><span class="n">alert</span> <span class="o">=</span> <span class="p">[[</span><span class="n">UIAlertView</span> <span class="n">alloc</span><span class="p">]</span> <span class="n">initWithTitle</span><span class="o">:</span><span class="s">@"You Didn’t Save!"</span>
                      <span class="nl">message:</span><span class="s">@"You will lose changes."</span>
                     <span class="nl">delegate:</span><span class="nb">nil</span>
            <span class="nl">cancelButtonTitle:</span><span class="s">@"Cancel"</span>
            <span class="nl">otherButtonTitles:</span><span class="s">@"Lose Changes"</span><span class="p">,</span> <span class="s">@"Panic"</span><span class="p">,</span> <span class="nb">nil</span><span class="p">];</span>

<span class="n">alert</span><span class="p">.</span><span class="n">promise</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span> <span class="o">*</span><span class="n">dismissedIndex</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<p>This Promise will not trigger a <code>catch</code> handler. At one point we had the cancel button trigger <code>catch</code>, but this led to unreliable error handling. Only errors trigger <code>catch</code> handlers.</p>

<h2>
<a name="uiactionsheetpromisekit" class="anchor" href="#uiactionsheetpromisekit"><span class="octicon octicon-link"></span></a>UIActionSheet+PromiseKit</h2>

<p>Same pattern as for <code>UIAlertView</code>.</p>

<h2>
<a name="uiviewcontrollerpromisekit" class="anchor" href="#uiviewcontrollerpromisekit"><span class="octicon octicon-link"></span></a>UIViewController+PromiseKit</h2>

<p>We provide a pattern for modally presenting ViewControllers and getting back a result:</p>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+UIKit.h"</span>

<span class="k">@implementation</span> <span class="nc">MyRootViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">foo</span> <span class="p">{</span>
    <span class="n">UIViewController</span> <span class="o">*</span><span class="n">vc</span> <span class="o">=</span> <span class="p">[</span><span class="n">MyDetailViewController</span> <span class="n">new</span><span class="p">];</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">promiseViewController</span><span class="o">:</span><span class="n">vc</span> <span class="n">animated</span><span class="o">:</span><span class="nb">YES</span> <span class="n">completion</span><span class="o">:</span><span class="nb">nil</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">result</span><span class="p">){</span>
        <span class="c1">// the result from below in `someTimeLater`</span>
        <span class="c1">// PromiseKit automatically dismisses the MyDetailViewController</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">@end</span>

<span class="k">@implementation</span> <span class="nc">MyDetailViewController</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">someTimeLater</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">fulfill</span><span class="o">:</span><span class="n">someResult</span><span class="p">];</span>

    <span class="c1">// if you want to trigger the `catch` use `[self reject:foo]`</span>
<span class="p">}</span>

<span class="k">@end</span>
</pre></div>

<p>As a bonus if you pass a <code>MFMailComposeViewController</code> we handle its delegation behind the scenes and convert it into a Promise:</p>

<div class="highlight highlight-objc"><pre><span class="kt">id</span> <span class="n">mailer</span> <span class="o">=</span> <span class="p">[</span><span class="n">MFMailComposerViewController</span> <span class="n">new</span><span class="p">];</span>
<span class="p">[</span><span class="n">self</span> <span class="n">promiseViewController</span><span class="o">:</span><span class="n">mailer</span> <span class="n">animated</span><span class="o">:</span><span class="nb">YES</span> <span class="n">completion</span><span class="o">:</span><span class="nb">nil</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSNumber</span>  <span class="o">*</span><span class="n">num</span><span class="p">){</span>
    <span class="c1">// num is the result passed from the MFMailComposeViewControllerDelegate</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">// the error from the delegate if that happened</span>
<span class="p">})</span>
</pre></div>

<p>Please submit equivalents for eg. <code>UIImagePickerController</code>.</p>

<h2>
<a name="mkdirectionspromisekit" class="anchor" href="#mkdirectionspromisekit"><span class="octicon octicon-link"></span></a>MKDirections+PromiseKit</h2>

<div class="highlight highlight-objc"><pre><span class="cp">#import "PromiseKit+MapKit.h"</span>

<span class="n">MKDirectionsRequest</span> <span class="o">*</span><span class="n">rq</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKDirectionsRequest</span> <span class="n">new</span><span class="p">];</span>
<span class="n">rq</span><span class="p">.</span><span class="n">source</span> <span class="o">=</span> <span class="p">[</span><span class="n">MKMapItem</span> <span class="n">mapItemForCurrentLocation</span><span class="p">];</span>
<span class="n">rq</span><span class="p">.</span><span class="n">destination</span> <span class="o">=</span> <span class="err">…</span><span class="p">;</span>
<span class="p">[</span><span class="n">MKDirections</span> <span class="n">promise</span><span class="o">:</span><span class="n">rq</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">MKDirectionsResponse</span> <span class="o">*</span><span class="n">rsp</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>

<span class="p">[</span><span class="n">MKDirections</span> <span class="n">promiseETA</span><span class="o">:</span><span class="n">rq</span><span class="p">].</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">MKETAResponse</span> <span class="o">*</span><span class="n">rsp</span><span class="p">){</span>
    <span class="c1">//…</span>
<span class="p">}).</span><span class="n">catch</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
    <span class="c1">//…</span>
<span class="p">});</span>
</pre></div>

<h1>
<a name="more-documentation" class="anchor" href="#more-documentation"><span class="octicon octicon-link"></span></a>More Documentation</h1>

<p>Check out <a href="PromiseKit/Promise.h">Promise.h</a> and the rest of the sources.</p>

<h1>
<a name="promizing-your-codebase" class="anchor" href="#promizing-your-codebase"><span class="octicon octicon-link"></span></a>Promizing Your Codebase</h1>

<p>This:</p>

<div class="highlight highlight-objc"><pre><span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">calculateTenThousandRandomNumbersWithCompletionBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">(</span><span class="o">^</span><span class="p">)(</span><span class="n">NSArray</span> <span class="o">*</span><span class="p">))</span><span class="nv">completionBlock</span> <span class="p">{</span>
    <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_global_queue</span><span class="p">(</span><span class="n">DISPATCH_QUEUE_PRIORITY_DEFAULT</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="o">^</span><span class="p">{</span>
        <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
            <span class="p">[</span><span class="n">numbers</span> <span class="n">addObject</span><span class="o">:</span><span class="p">@(</span><span class="n">arc4random</span><span class="p">())];</span>
        <span class="n">dispatch_async</span><span class="p">(</span><span class="n">dispatch_get_main_queue</span><span class="p">(),</span> <span class="o">^</span><span class="p">{</span>
            <span class="n">completionBlock</span><span class="p">(</span><span class="n">numbers</span><span class="p">);</span>
        <span class="p">});</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
    <span class="p">[</span><span class="n">self</span> <span class="n">calculateTenThousandRandomNumbersWithCompletionBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">numbers</span><span class="p">){</span>
        <span class="c1">//…</span>
    <span class="p">}];</span>
<span class="p">}</span>
</pre></div>

<p>Becomes this:</p>

<div class="highlight highlight-objc"><pre><span class="k">-</span> <span class="p">(</span><span class="n">Promise</span> <span class="o">*</span><span class="p">)</span><span class="nf">tenThousandRandomNumbers</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">dispatch_promise</span><span class="p">(</span><span class="o">^</span><span class="p">{</span>
        <span class="n">NSMutableArray</span> <span class="o">*</span><span class="n">numbers</span> <span class="o">=</span> <span class="p">[</span><span class="n">NSMutableArray</span> <span class="n">new</span><span class="p">];</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">10000</span><span class="p">;</span> <span class="n">x</span><span class="o">++</span><span class="p">)</span>
            <span class="p">[</span><span class="n">numbers</span> <span class="n">addObject</span><span class="o">:</span><span class="p">@(</span><span class="n">arc4random</span><span class="p">())];</span>
        <span class="k">return</span> <span class="n">numbers</span><span class="p">;</span>
    <span class="p">});</span>
<span class="p">}</span>

<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">viewDidLoad</span> <span class="p">{</span>
    <span class="n">self</span><span class="p">.</span><span class="n">tenThousandRandomNumbers</span><span class="p">.</span><span class="n">then</span><span class="p">(</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">numbers</span><span class="p">){</span>
        <span class="c1">//…</span>
    <span class="p">}];</span>
<span class="p">}</span>
</pre></div>

<h2>
<a name="wrapping-eg-parse" class="anchor" href="#wrapping-eg-parse"><span class="octicon octicon-link"></span></a>Wrapping e.g. Parse</h2>

<div class="highlight highlight-objc"><pre><span class="k">-</span> <span class="p">(</span><span class="n">Promise</span> <span class="o">*</span><span class="p">)</span><span class="nf">allUsers</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">Promise</span> <span class="n">new</span><span class="o">:^</span><span class="p">(</span><span class="n">PromiseResolver</span> <span class="n">fulfiller</span><span class="p">,</span> <span class="n">PromiseResolver</span> <span class="n">rejecter</span><span class="p">){</span>
        <span class="n">PFQuery</span> <span class="o">*</span><span class="n">query</span> <span class="o">=</span> <span class="p">[</span><span class="n">PFQuery</span> <span class="n">queryWithClassName</span><span class="o">:</span><span class="s">@"User"</span><span class="p">];</span>
        <span class="p">[</span><span class="n">query</span> <span class="n">findObjectsInBackgroundWithBlock</span><span class="o">:^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">objects</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">fulfiller</span><span class="p">(</span><span class="n">objects</span><span class="p">);</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">rejecter</span><span class="p">(</span><span class="n">error</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}];</span>
    <span class="p">}];</span>
<span class="p">}</span>
</pre></div>

<p><code>PromiseResolver</code> is <code>typedef void (^PromiseResolver)(id)</code>, i.e. a block that takes a parameter of <code>id</code> and returns <code>void</code>.</p>

<h1>
<a name="adding-promises-to-third-party-libraries" class="anchor" href="#adding-promises-to-third-party-libraries"><span class="octicon octicon-link"></span></a>Adding Promises to Third Party Libraries</h1>

<p>It would be great if every library with asynchronous functionality would offer opt-in <code>Promise *</code> variants for the asynchronous mechanisms.</p>

<p>Should you want to add PromiseKit integration to your library, the general premise is to add an opt-in <code>subspec</code> to your <code>podspec</code> that provides methods that return <code>Promise</code>s. For example if we imagine a library that overlays a kitten on an image:</p>

<div class="highlight highlight-objc"><pre><span class="k">@interface</span> <span class="nc">ABCKitten</span>
<span class="k">-</span> <span class="p">(</span><span class="n">instancetype</span><span class="p">)</span><span class="nf">initWithImage:</span><span class="p">(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">)</span><span class="nv">image</span><span class="p">;</span>
<span class="k">-</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nf">overlayKittenWithCompletionBlock:</span><span class="p">(</span><span class="kt">void</span><span class="p">)(</span><span class="o">^</span><span class="p">)(</span><span class="n">UIImage</span> <span class="o">*</span><span class="p">,</span> <span class="n">NSError</span> <span class="o">*</span><span class="p">))</span><span class="nv">completionBlock</span><span class="p">;</span>
<span class="k">@end</span>
</pre></div>

<p>Opt-in PromiseKit support would include a new file <code>ABCKitten+PromiseKit.h</code>:</p>

<div class="highlight highlight-objc"><pre><span class="cp">#import &lt;PromiseKit/Promise.h&gt;</span>
<span class="cp">#import "ABCKitten.h"</span>


<span class="k">@interface</span> <span class="nc">ABCKitten</span> <span class="nl">(PromiseKit)</span>

<span class="cm">/**</span>
<span class="cm"> * Returns a Promise that overlays a kitten image.</span>
<span class="cm"> * @return A Promise that will `then` a `UIImage *` object.</span>
<span class="cm"> */</span>
<span class="k">-</span> <span class="p">(</span><span class="n">Promise</span> <span class="o">*</span><span class="p">)</span><span class="nf">overlayKitten</span><span class="p">;</span>

<span class="k">@end</span>
</pre></div>

<p>It's crucially important to document your Promise methods <a href="http://nshipster.com/documentation/">properly</a>, because subsequent <code>then</code>s are not strongly typed, thus the only clue the user has is how you named your method and the documentation they can get when <strong>⌥</strong> clicking that method.</p>

<p>Consumers of your library would then include in their <code>Podfile</code>:</p>

<div class="highlight highlight-ruby"><pre><span class="n">pod</span> <span class="s1">'ABCKitten/PromiseKit'</span>
</pre></div>

<p>This is the “opt-in” step.</p>

<p>Finally you need to modify your <code>podspec</code>. If it was something like this:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Pod</span><span class="o">::</span><span class="no">Spec</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
  <span class="n">s</span><span class="o">.</span><span class="n">name</span>         <span class="o">=</span> <span class="s2">"ABCKitten"</span>
  <span class="n">s</span><span class="o">.</span><span class="n">version</span>      <span class="o">=</span> <span class="s2">"1.1"</span>
  <span class="n">s</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">'ABCKitten.{m,h}'</span>
<span class="k">end</span>
</pre></div>

<p>Then you would need to convert it to the following:</p>

<div class="highlight highlight-ruby"><pre><span class="no">Pod</span><span class="o">::</span><span class="no">Spec</span><span class="o">.</span><span class="n">new</span> <span class="k">do</span> <span class="o">|</span><span class="n">s</span><span class="o">|</span>
  <span class="n">s</span><span class="o">.</span><span class="n">name</span>         <span class="o">=</span> <span class="s2">"ABCKitten"</span>
  <span class="n">s</span><span class="o">.</span><span class="n">version</span>      <span class="o">=</span> <span class="s2">"1.1"</span>

  <span class="n">s</span><span class="o">.</span><span class="n">default_subspec</span> <span class="o">=</span> <span class="s1">'base'</span>  <span class="c1"># ensures that the PromiseKit additions are opt-in</span>

  <span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">'base'</span> <span class="k">do</span> <span class="o">|</span><span class="n">ss</span><span class="o">|</span>
    <span class="n">ss</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">'ABCKitten.{m,h}'</span>
  <span class="k">end</span>

  <span class="n">s</span><span class="o">.</span><span class="n">subspec</span> <span class="s1">'PromiseKit'</span> <span class="k">do</span> <span class="o">|</span><span class="n">ss</span><span class="o">|</span>
    <span class="n">ss</span><span class="o">.</span><span class="n">dependency</span> <span class="s1">'PromiseKit/base'</span><span class="p">,</span> <span class="s1">'ABCKitten/base'</span>
    <span class="n">ss</span><span class="o">.</span><span class="n">source_files</span> <span class="o">=</span> <span class="s1">'ABCKitten+PromiseKit.{m,h}'</span>
  <span class="k">end</span>
<span class="k">end</span>
</pre></div>

<h2>
<a name="adding-promisekit-to-someone-elses-pod" class="anchor" href="#adding-promisekit-to-someone-elses-pod"><span class="octicon octicon-link"></span></a>Adding PromiseKit to Someone Else’s Pod</h2>

<p>Firstly you should try submitting the above to the project itself. If they won’t add it then you'll need to make your own pod. Use the naming scheme: <code>ABCKitten+PromiseKit</code>.</p>

<h1>
<a name="why-promisekit" class="anchor" href="#why-promisekit"><span class="octicon octicon-link"></span></a>Why PromiseKit?</h1>

<p>There are other Promise implementations for iOS, but in this author’s opinion, none of them are as pleasant to use as PromiseKit.</p>

<ul>
<li>
<a href="https://github.com/BoltsFramework/Bolts-iOS">Bolts</a> was the inspiration for PromiseKit. I thought that—finally—someone had written a decent Promises implementation for iOS. The lack of dedicated <code>catch</code> handler, the (objectively) ugly syntax and the overly complex design was a disappointment. To be fair Bolts is not a Promise implementation, it’s…something else. You may like it, and certainly it is backed by big names™. Fundamentally, Promise-type implementations are not hard to write, so really you’re making a decision based on how flexible the API is while simulatenously producing readable, clean code. I have worked hard to make PromiseKit the best choice.</li>
<li>
<a href="https://github.com/couchdeveloper/RXPromise">RXPromise</a> is an excellent Promise implementation that is not quite perfect (IMHO). By default thens are executed in background threads, which usually is inconvenient. <code>then</code> always return <code>id</code> and always take <code>id</code>, which makes code less elegant. There is no explicit <code>catch</code>, instead <code>then</code> always takes two blocks, the second being the error handler, which is ugly. The interface for <code>Promise</code> allows any caller to resolve it breaking encapsulation. Otherwise an excellent implementation.</li>
<li>
<a href="https://github.com/Strilanc/ObjC-CollapsingFutures">CollapsingFutures</a> looks good, but is not thoroughly documented so a thorough review would require further experimentation.</li>
<li><a href="http://cocoapods.org/?q=promise">Many others</a></li>
</ul><p>PromiseKit is well tested, and inside apps on the store. It also is fully documented, even within Xcode (⌥ click any method).</p>

<h1>
<a name="caveats" class="anchor" href="#caveats"><span class="octicon octicon-link"></span></a>Caveats</h1>

<ul>
<li>We are version 0.9 and thus reserve the right to remove/change API before 1.0. Probably we won’t; we’re just being prudent by stating this advisory.</li>
<li>PromiseKit is not thread-safe. This is not intentional, we will fix that. However, in practice the only way to compromise PromiseKit is to keep a pointer to an pending Promise and use that from multiple threads. You can execute thens in many different contexts and the underlying immutability of Promises means PromiseKit is inherently thread-safe.</li>
<li>If you don't have at least one catch handler in your chain then errors are silently absorbed which may cause you confusion. We intend to log unhandled errors, (with an opt-in method to have them get thrown and thus crash your app in cases where that is desired).</li>
</ul><h1>
<a name="promisesa-compliance" class="anchor" href="#promisesa-compliance"><span class="octicon octicon-link"></span></a>Promises/A+ Compliance</h1>

<p>PromiseKit is <a href="http://promisesaplus.com">compliant</a> excluding:</p>

<ul>
<li>Our <code>then</code> does not take a failure handler, instead we have a dedicated <code>catch</code>
</li>
</ul><p>If you find further non-compliance please open a <a href="https://github.com/mxcl/PromiseKit/issues/new">ticket</a>.</p>

<h1>
<a name="terminology" class="anchor" href="#terminology"><span class="octicon octicon-link"></span></a>Terminology</h1>

<ul>
<li>Promises start in a <strong>pending</strong> state.</li>
<li>Promises <strong>resolve</strong> to become <strong>fulfilled</strong> or <strong>rejected</strong>.</li>
</ul><h1>
<a name="the-fine-print" class="anchor" href="#the-fine-print"><span class="octicon octicon-link"></span></a>The Fine Print</h1>

<p>The fine print of PromiseKit is mostly exactly what you would expect, so don’t confuse yourself: only come back here when you find yourself curious about more advanced techniques.</p>

<ul>
<li>Returning a Promise as the value of a <code>then</code> (or <code>catch</code>) handler will cause any subsequent handlers to wait for that Promise to resolve.</li>
<li>Returning an instance of <code>NSError</code> or throwing an exception within a then block will cause PromiseKit to bubble that object up to the nearest catch handler.</li>
<li>
<code>catch</code> handlers always are passed an <code>NSError</code> object.</li>
<li>Returning something other than an <code>NSError</code> from a <code>catch</code> handler causes PromiseKit to consider the error “corrected”, and execution will continue at the next <code>then</code> handler using the object you returned as the input.</li>
<li>Not returning from a <code>catch</code> handler (or returning nil) causes PromiseKit to consider the Promise complete. No further bubbling occurs.</li>
<li>Nothing happens if you add a <code>then</code> to a failed Promise (unless you subsequently add a <code>catch</code> handler to the Promise returned from that <code>then</code>)</li>
<li>Adding a <code>catch</code> handler to a failed Promise will execute that fail handler: this is converse to adding the same to a <strong>pending</strong> Promise that has a higher <code>catch</code> than the one you just added.</li>
</ul>
      </section>
    </div>
    <footer>
      <p>Project maintained by <a href="https://github.com/mxcl">mxcl</a></p>
      <p>Hosted on GitHub Pages &mdash; Theme by <a href="https://github.com/orderedlist">orderedlist</a></p>
    </footer>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>